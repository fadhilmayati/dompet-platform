"""Lightweight persistence layer for Dompet AI sessions."""

from __future__ import annotations

import sqlite3
import threading
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence

import json

from .orchestrator import Transaction


@dataclass
class AnalysisRecord:
    """Represents a stored analysis result for a single agent."""

    run_id: str
    agent_key: str
    content: str
    context: str
    run_at: datetime


@dataclass
class UserProfile:
    """Structured representation of persisted behavioural traits."""

    user_id: str
    risk_tolerance: str
    response_style: str
    success_notes: str
    success_metrics: Dict[str, Dict[str, int]]
    created_at: datetime
    updated_at: datetime


@dataclass
class SuggestionRecord:
    """Single suggestion generated by an agent during an analysis run."""

    id: int
    user_id: str
    run_id: str
    agent_key: str
    suggestion: str
    suggestion_type: str
    created_at: datetime
    latest_outcome: Optional[str]
    latest_impact: Optional[float]


@dataclass
class ImpactSnapshot:
    """Aggregated metrics about suggestions and behaviour change."""

    total_suggestions: int
    acted_upon: int
    failed: int
    ignored: int
    estimated_savings: float
    last_action_at: Optional[datetime]


class SessionStore:
    """SQLite-backed storage for transactions and agent outputs."""

    def __init__(self, db_path: str | Path = "dompet_ai.sqlite") -> None:
        self.db_path = Path(db_path)
        self._lock = threading.Lock()
        self._connection = sqlite3.connect(self.db_path, check_same_thread=False)
        self._connection.row_factory = sqlite3.Row
        self._initialise()

    def _initialise(self) -> None:
        with self._connection:
            self._connection.execute(
                """
                CREATE TABLE IF NOT EXISTS transactions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    date TEXT NOT NULL,
                    description TEXT NOT NULL,
                    amount REAL NOT NULL,
                    source TEXT NOT NULL DEFAULT 'api',
                    created_at TEXT NOT NULL DEFAULT (datetime('now')),
                    UNIQUE(user_id, date, description, amount)
                )
                """
            )
            self._connection.execute(
                """
                CREATE TABLE IF NOT EXISTS analyses (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    run_id TEXT NOT NULL,
                    agent_key TEXT NOT NULL,
                    content TEXT NOT NULL,
                    context TEXT NOT NULL,
                    run_at TEXT NOT NULL DEFAULT (datetime('now'))
                )
                """
            )
            self._connection.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_transactions_user_date
                ON transactions (user_id, date DESC)
                """
            )
            self._connection.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_analyses_user_run
                ON analyses (user_id, run_at DESC)
                """
            )
            self._connection.execute(
                """
                CREATE TABLE IF NOT EXISTS user_profiles (
                    user_id TEXT PRIMARY KEY,
                    risk_tolerance TEXT NOT NULL DEFAULT 'balanced',
                    response_style TEXT NOT NULL DEFAULT 'supportive',
                    success_notes TEXT NOT NULL DEFAULT '',
                    success_metrics TEXT NOT NULL DEFAULT '{}',
                    created_at TEXT NOT NULL DEFAULT (datetime('now')),
                    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
                )
                """
            )
            self._connection.execute(
                """
                CREATE TABLE IF NOT EXISTS suggestions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    run_id TEXT NOT NULL,
                    agent_key TEXT NOT NULL,
                    suggestion TEXT NOT NULL,
                    suggestion_type TEXT NOT NULL,
                    created_at TEXT NOT NULL DEFAULT (datetime('now'))
                )
                """
            )
            self._connection.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_suggestions_user
                ON suggestions (user_id, created_at DESC)
                """
            )
            self._connection.execute(
                """
                CREATE TABLE IF NOT EXISTS suggestion_outcomes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    suggestion_id INTEGER NOT NULL,
                    outcome_status TEXT NOT NULL,
                    impact REAL,
                    notes TEXT,
                    recorded_at TEXT NOT NULL DEFAULT (datetime('now')),
                    FOREIGN KEY (suggestion_id) REFERENCES suggestions (id)
                )
                """
            )
            self._connection.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_outcomes_suggestion
                ON suggestion_outcomes (suggestion_id, recorded_at DESC)
                """
            )
            self._connection.execute(
                """
                CREATE TABLE IF NOT EXISTS user_goals (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    name TEXT NOT NULL,
                    target_amount REAL NOT NULL,
                    target_date TEXT,
                    current_progress REAL NOT NULL DEFAULT 0,
                    notes TEXT,
                    status TEXT NOT NULL DEFAULT 'active',
                    created_at TEXT NOT NULL DEFAULT (datetime('now')),
                    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
                )
                """
            )
            self._connection.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_goals_user_status
                ON user_goals (user_id, status, target_date)
                """
            )

    def add_transactions(
        self, user_id: str, transactions: Sequence[Transaction], source: str = "api"
    ) -> int:
        """Persist a batch of transactions for a user."""

        if not transactions:
            return 0

        rows = [
            (user_id, tx.date, tx.description, tx.amount, source)
            for tx in transactions
        ]

        with self._lock:
            cursor = self._connection.executemany(
                """
                INSERT OR IGNORE INTO transactions (
                    user_id, date, description, amount, source
                ) VALUES (?, ?, ?, ?, ?)
                """,
                rows,
            )
            self._connection.commit()
        return cursor.rowcount

    def fetch_recent_transactions(
        self, user_id: str, limit: int = 50
    ) -> List[Transaction]:
        """Return the most recent transactions for a user."""

        cursor = self._connection.execute(
            """
            SELECT date, description, amount
            FROM transactions
            WHERE user_id = ?
            ORDER BY date DESC, id DESC
            LIMIT ?
            """,
            (user_id, limit),
        )
        return [
            Transaction(
                date=row["date"], description=row["description"], amount=row["amount"]
            )
            for row in cursor.fetchall()
        ]

    def record_analysis(
        self, user_id: str, run_id: str, agent_key: str, content: str, context: str
    ) -> None:
        """Persist an analysis output for later retrieval."""

        with self._lock:
            self._connection.execute(
                """
                INSERT INTO analyses (user_id, run_id, agent_key, content, context)
                VALUES (?, ?, ?, ?, ?)
                """,
                (user_id, run_id, agent_key, content, context),
            )
            self._connection.commit()

    def latest_analysis(self, user_id: str) -> List[AnalysisRecord]:
        """Return the most recent analysis run for the user."""

        cursor = self._connection.execute(
            """
            SELECT run_id, run_at
            FROM analyses
            WHERE user_id = ?
            ORDER BY run_at DESC
            LIMIT 1
            """,
            (user_id,),
        )
        row = cursor.fetchone()
        if row is None:
            return []

        run_id = row["run_id"]
        cursor = self._connection.execute(
            """
            SELECT run_id, agent_key, content, context, run_at
            FROM analyses
            WHERE user_id = ? AND run_id = ?
            ORDER BY agent_key ASC
            """,
            (user_id, run_id),
        )
        records: List[AnalysisRecord] = []
        for record in cursor.fetchall():
            records.append(
                AnalysisRecord(
                    run_id=record["run_id"],
                    agent_key=record["agent_key"],
                    content=record["content"],
                    context=record["context"],
                    run_at=datetime.fromisoformat(record["run_at"]),
                )
            )
        return records

    def analysis_history(self, user_id: str, limit: int = 5) -> List[List[AnalysisRecord]]:
        """Return a limited number of past analysis runs grouped by run ID."""

        cursor = self._connection.execute(
            """
            SELECT run_id, MIN(run_at) as first_seen
            FROM analyses
            WHERE user_id = ?
            GROUP BY run_id
            ORDER BY first_seen DESC
            LIMIT ?
            """,
            (user_id, limit),
        )

        runs: List[List[AnalysisRecord]] = []
        for row in cursor.fetchall():
            run_id = row["run_id"]
            per_run = self._connection.execute(
                """
                SELECT agent_key, content, context, run_at
                FROM analyses
                WHERE user_id = ? AND run_id = ?
                ORDER BY agent_key ASC
                """,
                (user_id, run_id),
            )
            run_records = [
                AnalysisRecord(
                    run_id=run_id,
                    agent_key=record["agent_key"],
                    content=record["content"],
                    context=record["context"],
                    run_at=datetime.fromisoformat(record["run_at"]),
                )
                for record in per_run.fetchall()
            ]
            runs.append(run_records)
        return runs

    # ------------------------------------------------------------------
    # User profile management
    # ------------------------------------------------------------------

    def get_or_create_user_profile(self, user_id: str) -> UserProfile:
        """Fetch the behavioural profile for a user, creating defaults if missing."""

        with self._lock:
            cursor = self._connection.execute(
                "SELECT * FROM user_profiles WHERE user_id = ?", (user_id,)
            )
            row = cursor.fetchone()
            if row is None:
                self._connection.execute(
                    """
                    INSERT INTO user_profiles (user_id)
                    VALUES (?)
                    """,
                    (user_id,),
                )
                self._connection.commit()
                cursor = self._connection.execute(
                    "SELECT * FROM user_profiles WHERE user_id = ?", (user_id,)
                )
                row = cursor.fetchone()

        return self._row_to_profile(row)

    def update_user_profile(
        self,
        user_id: str,
        *,
        risk_tolerance: Optional[str] = None,
        response_style: Optional[str] = None,
        success_notes: Optional[str] = None,
    ) -> UserProfile:
        """Update editable profile attributes and return the new snapshot."""

        assignments: List[str] = []
        params: List[object] = []
        if risk_tolerance is not None:
            assignments.append("risk_tolerance = ?")
            params.append(risk_tolerance)
        if response_style is not None:
            assignments.append("response_style = ?")
            params.append(response_style)
        if success_notes is not None:
            assignments.append("success_notes = ?")
            params.append(success_notes)
        assignments.append("updated_at = datetime('now')")

        if assignments:
            params.append(user_id)
            with self._lock:
                self._connection.execute(
                    f"UPDATE user_profiles SET {', '.join(assignments)} WHERE user_id = ?",
                    params,
                )
                self._connection.commit()
        return self.get_or_create_user_profile(user_id)

    def _row_to_profile(self, row: sqlite3.Row) -> UserProfile:
        success_metrics = json.loads(row["success_metrics"] or "{}")
        return UserProfile(
            user_id=row["user_id"],
            risk_tolerance=row["risk_tolerance"],
            response_style=row["response_style"],
            success_notes=row["success_notes"],
            success_metrics=success_metrics,
            created_at=datetime.fromisoformat(row["created_at"]),
            updated_at=datetime.fromisoformat(row["updated_at"]),
        )

    # ------------------------------------------------------------------
    # Suggestions and outcomes
    # ------------------------------------------------------------------

    def record_suggestions(
        self,
        user_id: str,
        run_id: str,
        agent_key: str,
        suggestion_type: str,
        suggestions: Iterable[str],
    ) -> List[SuggestionRecord]:
        """Persist generated suggestions for follow-up tracking."""

        stored: List[SuggestionRecord] = []
        to_insert = [suggestion.strip() for suggestion in suggestions if suggestion.strip()]
        if not to_insert:
            return stored

        with self._lock:
            self._connection.executemany(
                """
                INSERT INTO suggestions (user_id, run_id, agent_key, suggestion, suggestion_type)
                VALUES (?, ?, ?, ?, ?)
                """,
                [
                    (user_id, run_id, agent_key, suggestion, suggestion_type)
                    for suggestion in to_insert
                ],
            )
            self._connection.commit()
            cursor = self._connection.execute(
                """
                SELECT
                    s.id,
                    s.user_id,
                    s.run_id,
                    s.agent_key,
                    s.suggestion,
                    s.suggestion_type,
                    s.created_at,
                    (
                        SELECT outcome_status
                        FROM suggestion_outcomes AS o
                        WHERE o.suggestion_id = s.id
                        ORDER BY recorded_at DESC
                        LIMIT 1
                    ) AS latest_outcome,
                    (
                        SELECT impact
                        FROM suggestion_outcomes AS o
                        WHERE o.suggestion_id = s.id
                        ORDER BY recorded_at DESC
                        LIMIT 1
                    ) AS latest_impact
                FROM suggestions AS s
                WHERE s.user_id = ? AND s.run_id = ? AND s.agent_key = ?
                ORDER BY s.created_at DESC
                LIMIT ?
                """,
                (user_id, run_id, agent_key, len(to_insert)),
            )
            rows = cursor.fetchall()

        for row in rows:
            stored.append(
                SuggestionRecord(
                    id=row["id"],
                    user_id=row["user_id"],
                    run_id=row["run_id"],
                    agent_key=row["agent_key"],
                    suggestion=row["suggestion"],
                    suggestion_type=row["suggestion_type"],
                    created_at=datetime.fromisoformat(row["created_at"]),
                    latest_outcome=row["latest_outcome"],
                    latest_impact=row["latest_impact"],
                )
            )
        if stored:
            stored.sort(key=lambda record: record.created_at)
            self._refresh_success_metrics(user_id)
        return stored

    def get_suggestions_for_run(self, user_id: str, run_id: str) -> List[SuggestionRecord]:
        """Return all suggestions generated within a particular run."""

        cursor = self._connection.execute(
            """
            SELECT
                s.id,
                s.user_id,
                s.run_id,
                s.agent_key,
                s.suggestion,
                s.suggestion_type,
                s.created_at,
                (
                    SELECT outcome_status
                    FROM suggestion_outcomes AS o
                    WHERE o.suggestion_id = s.id
                    ORDER BY recorded_at DESC
                    LIMIT 1
                ) AS latest_outcome,
                (
                    SELECT impact
                    FROM suggestion_outcomes AS o
                    WHERE o.suggestion_id = s.id
                    ORDER BY recorded_at DESC
                    LIMIT 1
                ) AS latest_impact
            FROM suggestions AS s
            WHERE s.user_id = ? AND s.run_id = ?
            ORDER BY s.created_at ASC
            """,
            (user_id, run_id),
        )
        records: List[SuggestionRecord] = []
        for row in cursor.fetchall():
            records.append(
                SuggestionRecord(
                    id=row["id"],
                    user_id=row["user_id"],
                    run_id=row["run_id"],
                    agent_key=row["agent_key"],
                    suggestion=row["suggestion"],
                    suggestion_type=row["suggestion_type"],
                    created_at=datetime.fromisoformat(row["created_at"]),
                    latest_outcome=row["latest_outcome"],
                    latest_impact=row["latest_impact"],
                )
            )
        return records

    def record_suggestion_outcome(
        self,
        suggestion_id: int,
        outcome_status: str,
        impact: Optional[float] = None,
        notes: Optional[str] = None,
    ) -> str:
        """Persist a follow-up outcome for a suggestion.

        Returns the user identifier owning the suggestion for validation.
        """

        with self._lock:
            cursor = self._connection.execute(
                "SELECT user_id FROM suggestions WHERE id = ?",
                (suggestion_id,),
            )
            row = cursor.fetchone()
            if row is None:
                raise ValueError("Unknown suggestion_id")
            user_id = row["user_id"]
            self._connection.execute(
                """
                INSERT INTO suggestion_outcomes (suggestion_id, outcome_status, impact, notes)
                VALUES (?, ?, ?, ?)
                """,
                (suggestion_id, outcome_status, impact, notes),
            )
            self._connection.commit()
        self._refresh_success_metrics(user_id)
        return user_id

    def _refresh_success_metrics(self, user_id: str) -> None:
        """Recalculate success metrics and store them on the profile."""

        cursor = self._connection.execute(
            """
            SELECT s.suggestion_type,
                   SUM(CASE WHEN o.outcome_status = 'acted' THEN 1 ELSE 0 END) AS acted,
                   COUNT(DISTINCT s.id) AS total
            FROM suggestions AS s
            LEFT JOIN suggestion_outcomes AS o ON o.suggestion_id = s.id
            WHERE s.user_id = ?
            GROUP BY s.suggestion_type
            """,
            (user_id,),
        )
        metrics: Dict[str, Dict[str, int]] = {}
        for row in cursor.fetchall():
            metrics[row["suggestion_type"]] = {
                "acted": row["acted"] or 0,
                "total": row["total"] or 0,
            }
        with self._lock:
            self._connection.execute(
                """
                UPDATE user_profiles
                SET success_metrics = ?, updated_at = datetime('now')
                WHERE user_id = ?
                """,
                (json.dumps(metrics), user_id),
            )
            self._connection.commit()

    def get_personalisation_notes(
        self, user_id: str, history_limit: int = 5
    ) -> str:
        """Build a natural language string summarising behavioural data."""

        profile = self.get_or_create_user_profile(user_id)
        parts = [
            f"Risk tolerance: {profile.risk_tolerance}.",
            f"Prefers coaching tone: {profile.response_style}.",
        ]
        if profile.success_notes:
            parts.append(f"Notes: {profile.success_notes}.")

        if profile.success_metrics:
            success_parts = []
            for suggestion_type, counts in profile.success_metrics.items():
                total = counts.get("total", 0)
                acted = counts.get("acted", 0)
                if total:
                    success_parts.append(
                        f"{suggestion_type} tips acted on {acted} of {total} times"
                    )
            if success_parts:
                parts.append("Performance: " + "; ".join(success_parts) + ".")

        cursor = self._connection.execute(
            """
            SELECT s.suggestion, s.suggestion_type, o.outcome_status, o.impact, o.recorded_at
            FROM suggestions AS s
            LEFT JOIN suggestion_outcomes AS o
              ON o.suggestion_id = s.id
            WHERE s.user_id = ?
            ORDER BY o.recorded_at DESC, s.created_at DESC
            LIMIT ?
            """,
            (user_id, history_limit),
        )
        rows = [row for row in cursor.fetchall() if row["outcome_status"]]
        if rows:
            history_lines = []
            for row in rows:
                detail = f"{row['suggestion_type']} tip '{row['suggestion']}'"
                detail += f" -> {row['outcome_status']}"
                if row["impact"] is not None:
                    detail += f" (impact RM{row['impact']:.2f})"
                history_lines.append(detail)
            parts.append("Recent outcomes: " + "; ".join(history_lines) + ".")

        return " ".join(parts)

    def get_impact_snapshot(self, user_id: str) -> ImpactSnapshot:
        """Aggregate behavioural impact metrics for reporting endpoints."""

        cursor = self._connection.execute(
            """
            SELECT COUNT(*) AS total
            FROM suggestions
            WHERE user_id = ?
            """,
            (user_id,),
        )
        total = cursor.fetchone()["total"] or 0

        cursor = self._connection.execute(
            """
            SELECT
                SUM(CASE WHEN outcome_status = 'acted' THEN 1 ELSE 0 END) AS acted,
                SUM(CASE WHEN outcome_status = 'failed' THEN 1 ELSE 0 END) AS failed,
                SUM(CASE WHEN outcome_status = 'ignored' THEN 1 ELSE 0 END) AS ignored,
                SUM(CASE WHEN outcome_status = 'acted' AND impact IS NOT NULL THEN impact ELSE 0 END)
                    AS savings,
                MAX(recorded_at) AS last_action
            FROM suggestion_outcomes
            WHERE suggestion_id IN (
                SELECT id FROM suggestions WHERE user_id = ?
            )
            """,
            (user_id,),
        )
        row = cursor.fetchone()
        last_action = row["last_action"]
        return ImpactSnapshot(
            total_suggestions=total,
            acted_upon=row["acted"] or 0,
            failed=row["failed"] or 0,
            ignored=row["ignored"] or 0,
            estimated_savings=row["savings"] or 0.0,
            last_action_at=datetime.fromisoformat(last_action) if last_action else None,
        )

    # ------------------------------------------------------------------
    # Goal storage helpers
    # ------------------------------------------------------------------

    def upsert_goal(
        self,
        user_id: str,
        name: str,
        target_amount: float,
        target_date: Optional[str],
        notes: Optional[str] = None,
    ) -> None:
        """Create a goal if missing or update the latest active entry."""

        with self._lock:
            cursor = self._connection.execute(
                """
                SELECT id FROM user_goals
                WHERE user_id = ? AND name = ? AND status = 'active'
                ORDER BY updated_at DESC
                LIMIT 1
                """,
                (user_id, name),
            )
            row = cursor.fetchone()
            if row is None:
                self._connection.execute(
                    """
                    INSERT INTO user_goals (user_id, name, target_amount, target_date, notes)
                    VALUES (?, ?, ?, ?, ?)
                    """,
                    (user_id, name, target_amount, target_date, notes),
                )
            else:
                goal_id = row["id"]
                self._connection.execute(
                    """
                    UPDATE user_goals
                    SET target_amount = ?, target_date = ?, notes = ?, updated_at = datetime('now')
                    WHERE id = ?
                    """,
                    (target_amount, target_date, notes, goal_id),
                )
            self._connection.commit()

    def list_goals(self, user_id: str) -> List[dict]:
        """Return all goals for the specified user ordered by status."""

        cursor = self._connection.execute(
            """
            SELECT id, name, target_amount, target_date, current_progress, notes, status,
                   created_at, updated_at
            FROM user_goals
            WHERE user_id = ?
            ORDER BY status ASC, target_date ASC
            """,
            (user_id,),
        )
        goals: List[dict] = []
        for row in cursor.fetchall():
            goals.append(
                {
                    "id": row["id"],
                    "name": row["name"],
                    "target_amount": row["target_amount"],
                    "target_date": row["target_date"],
                    "current_progress": row["current_progress"],
                    "notes": row["notes"],
                    "status": row["status"],
                    "created_at": row["created_at"],
                    "updated_at": row["updated_at"],
                }
            )
        return goals

    def goal_context(self, user_id: str) -> str:
        """Return a summary string of active goals for prompting."""

        cursor = self._connection.execute(
            """
            SELECT name, target_amount, target_date, current_progress
            FROM user_goals
            WHERE user_id = ? AND status = 'active'
            ORDER BY target_date ASC
            LIMIT 3
            """,
            (user_id,),
        )
        rows = cursor.fetchall()
        if not rows:
            return ""
        lines = []
        for row in rows:
            target_date = row["target_date"] or "unspecified date"
            lines.append(
                f"Goal '{row['name']}' target RM{row['target_amount']:.2f} by {target_date}"
            )
        return " | ".join(lines)

    def close(self) -> None:
        self._connection.close()


__all__ = [
    "SessionStore",
    "AnalysisRecord",
    "UserProfile",
    "SuggestionRecord",
    "ImpactSnapshot",
]
